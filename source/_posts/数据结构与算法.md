---
title: 数据结构与算法
date: 2019-03-14 13:58:10
categories: Basic
---
### 1. 数组
数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。

- 线性表
线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等都是线性表结构。
<img src="1.jpg" style="max-width: 500px; margin-top: 20px">

- *随机访问*
连续的内存空间和相同类型的数据。因为有了这个限制，它才有了一个堪称“杀手锏”的特性：**随机访问**。也因为这两个限制，让数组的很多操作变得非常低效，比如删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

- 数组如何通过下标随机访问?
通过寻址共识，计算出存储元素的内存地址。
```
a[i]_address = base_address + i * data_type_size

// 二位数组内存寻址
对于m * n的数组, a[i][j]( i < m, j < n)的地址为
a[i][j]_address = base_address + ( i * n + j ) * data_type_size
```

- *低效的“插入”和“删除”*
**为了保持内存数组的连续性**，将一个数据插入到数组中的第k个位置，我们需要将第k~n这部分的元素都顺序往后挪以为。平均情况时间复杂度为(1+2+..+n)/n = O(n).

- 改进方法（舍弃数组的连续性）
*快排*:  直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。时间复杂度降为O(1)
*JVM标记清除垃圾*:  删除操作，只是记录数据已经被删除。当数组没有更多空间存储数据时，才触发执行一次真正的删除操作。大大减少了数据搬移的次数。

- 数组的访问越界问题
- 为什么数组要从0开始编号?
如果从1开始编号，每次随机访问数组元素都多了一次减法运算。
```
// 从0开始
a[k]_address = base_address + k * type_size

// 从1开始
a[k]_address = base_address + ( k - 1 ) * type_size
```


<br/>
### 2. 链表
数组需要一块连续的内存空间来存储，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组**零散的内存块**串联起来使用。
<img src="2.jpg" style="max-width: 500px; margin-top: 20px">


<br/>
#### 2.1 单链表
为了将所有节点串起来，每个链表的节点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个节点地址的指针叫作**后续指针 next**。
<img src="3.jpg" style="max-width: 500px; margin: 20px auto">

与数组一样，链表也支持数据的查找、插入和删除。在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，我们只需要考虑相邻结点的指针改变，时间复杂度是O(1)。
<img src="4.jpg" style="max-width: 500px; margin: 20px auto">

但是，链表想要随机访问第k个元素，就无法像数组那样，通过寻址公式直接计算出对应的内存地址。而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，时间复杂度是O(n)。

<br/>
- **循环链表**
单链表的尾结点指针指向空地址，来表示这是最后的结点。而循环链表的尾结点指向链表的头结点。

<br/>
#### 2.2 双向链表
每个结点不止有一个后续指针`next`指向后面的结点，还有一个前驱指针`prev`指向签名的节点。
<img src="5.jpg" style="max-width: 500px; margin: 20px auto">

- **相比单链表，双向链表适合解决哪种问题？**
在实际的开发中，从链表中删除一个数据无外乎这两种情况：
*- 删除结点中“值等于某个给定值”的结点*
此时，无论是单链表还是双链表，都需要从头结点一个个遍历对比，知道遭到给定值的结点。时间复杂度是O(n)。
*- 删除给定指针指向的结点*
删除某个结点需要知道其前驱结点，而单链表不能直接获取。为了找到前驱结点，我们还要从头结点开始遍历链表，知道p->next = q。时间复杂度为O(n)，而双向链表只需O(1)。

<br/>
- **有序链表**
对于有序链表，双向链表的按值查询的效率更高。我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定往前还是往后查找，平均只需要查找一半的数据。 Java LinkedHashMap

<br/>
- **实现LRU缓存淘汰算法**
> 缓存是一种提高数据读取性能的技术，常见的有CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理，哪些数据应该被保留。这就需要缓存淘汰策略来决定。常见的策略有三种: 先进先出策略(FIFO - first in, first out), 最少使用策略(LFU - least frequently used), 最近最少使用策略(LRU - least recently used)。

*实现思路: 越靠近尾部的结点是越早前访问的。*
1. 维护一个有序单链表
2. 当要访问一个数据时，我们从链表头开始遍历链表。
如果数据已经存在于链表中，将其从原来的文职删除，再插入到链表的头部。
如果数据不存在于链表中，此时缓存未满，将此结点直接插入到链表的头部。
如果数据不存在与链表中，此时缓存已满，则删除链表尾结点，将新数据插入链表的头部。

<br/>
- **判断一个字符串是否是回文字符串**
使用快慢两个指针找到链表中点，慢指针每次前进1步，快指针每次前进2步。在慢指针前进的过程中，同时修改其next指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。

<br/>
#### 2.3 指针的含义
有的语言有“指针”的概念，有的没有，取而代之的是“引用”。无论是“指针”还是“引用”，指的都是存储所指对象的内存位置。

*将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。*

```
// p结点的next指针存储了q结点的内存地址
p->next=q

// p结点的next指针存储了p结点的下下一个结点的内存地址
p->next = p->next->next
```

- 单链表的插入删除
```
// 插入一个新结点
new_node->next = p->next;
p->next = new_node;

// 向一个空链表插入第一个结点
if( head == null ){
  head = new_node;
}

// 删除结点
p->next = p->next->next

// 删除最后一个结点
if( head->next == null ){
  head = null;
}
```

- 哨兵结点
哨兵结点是不存储数据的。

<br/>
### 3. 栈
后进者先出，先进者后出，这就是典型的“栈”结构。从操作特性来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。

- 用数组实现栈

```java
public class ArrayStack{
  private String[] items; // 数组
  private int count;      // 栈中元素个数
  private int n;          // 栈的大小

  // 初始化数组，申请一个大小为n的数组空间
  public ArrayStack(int n){
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入栈操作
  public boolean push(String item){
    if (count == n) return false;  // 数组空间不够了，入栈失败，返回false
    items[count] = item;
    ++count;
    return true;
  }

  // 出栈操作
  public String pop(){
    if (count == 0) return null;
    // 返回下标为count - 1 的数组元素，并且栈中元素个数count-1
    String tmp = items[count - 1];
    --count;
    return tmp;
  }
}
```


<br/>
- 函数调用栈

我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”，用来储存函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

```java
int main(){
  int a = 1;
  int ret = 0;
  int res = 0;
  ret = add(3, 5);
  res = a + ret;
  printf("%d", res);
}

int add(int x, int y){
  int sum = 0;
  sum = x + y;
  return sum;
}
```
<img src="6.jpg" style="max-width: 400px">

<br/>
- 表达式求值`3+5/*8-6`

编译器通过两个栈实现。其中一个保存操作数的栈，另一个保存运算符的栈。我们从左向右遍历表达式，当遇到数字，压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就压入栈。如果比栈顶元素优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，进行计算，再把计算完的结果压入操作数栈。继续比较。
<img src="7.jpg" style="max-width: 700px">


- 检查表达式中的括号是否匹配

表达式中包括三种括号`() {} []`，`{[{}]}, [{()}([])]`等都为合法格式，而`{[}()], [({)]`为不合法合适。如何检查它是否合法？

从左到右扫描字符串，当扫描到左括号时，将其压入栈中；当扫描到有右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果不能匹配，或栈中没有数据，则说明为非法格式。

<br/>
- **实现浏览器前进后退功能**

当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以看到b和a。当你后退到a，点击前进，就可以重新查看b和c。但是，如果你后退到b后，点击了新的页面d，就无法通过前进、后退功能查看c了。

当你顺序看了a,b,c三个页面，依次把a,b,c压入栈X。通过浏览器的后退按钮，从页面c退到页面a，我们依次把c,b从栈X中弹出，并且依次放入栈Y。
<img src="8.jpg" style="max-width: 500px">

这时，你在b页面上跳转到新页面d，页面c就无法再通过前进、后退按钮重复查看了，所以清空栈Y。
<img src="9.jpg" style="max-width: 500px">



<br/>
<br/>
### 4. 队列
先进者新出，和栈相似，队列有两个基本操作：入队，放一个数据到队列尾部；出队，从队列头部取一个元素。

<br/>
- *用数组实现队列*

```java
public class ArrayQueue{
  // 数组 items, 数组大小 n
  private String[] items;
  private int n = 0;
  // head 表示队头下标; tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为capacity的数组
  public ArrayQueue(int capacity){
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item){
    // tail == n 表示队列末尾没有空间了
    if (tail == n) {
      // tail == n && head == 0 表示整个队列占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; i++){
        items[i-head] = items[i]
      };
      // 数据搬移后重新更新head和tail
      tail -= head;
      head = 0;
    }
    items[tail] = item;
    ++tail;
    return true;
  }

  // 出队
  public String dequeue(){
    // head == tail 表示队列为空
    if (head == tial) return null;
    String ret = items[head];
    ++head;
    return ret;
  }
}
```
对于栈来说，我们只需要一个**栈顶指针**。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。
<img src="10.jpg" style="max-width: 600px">

<br/>
- *循环队列：避免数据搬移*

队满时，`(tail+1)%n=head`。可以发现，队满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个存储空间。
<img src="11.jpg" style="max-width: 600px">
```java
public class CircularQueue{
  // 数组 items, 数组大小 n
  private String[] items;
  private int n = 0;
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为capacity的数组
  public CircularQueue(int capacity){
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item){
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tial = (tial + 1) % n;
    return true; 
  }

  // 出队
  public String dequeue(){
    // 如果 head == tial 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}
```

- 阻塞队列： 生产者-消费者模型
当队列为空的时候，因为没有数据可取，从队头取数据会被阻塞。当队列已经满了，插入数据的操作就会被阻塞，知道队列中有空闲位置后才能插入数据。

<br/>
<br/>
### 5. 递归
递归就是用栈的数据结构，加上一个简单的逻辑算法实现了业务功能。所有的递归问题都可以用递推公式来表示。
```
f(n) = f(n - 1) + 1; 其中f(1) = 1;
```

f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个递推公式，我们可以得到递归代码
```java
int f(int n){
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

<br/>
- *写出递推公式，找到终止条件*

假设有n个台阶，每次你可以跨1或2个台阶，问走这n个台阶共有多种种走法？实际上，可以根据第一步的走法把所有走法分为两类，一类是先走1阶后，n-1个台阶的走法 + 先走2阶后，n-2个台阶的走法。
```
f(n) = f(n-1) + f(n-2)
```
当有1个台阶且走1阶，或有2个台阶走2阶时，即f(1) = 1, f(2) = 2，就不需要再递归。最终的递归代码是这样的：
```java
int f(int n){
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

<br/>
- 警惕栈堆溢出
每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险（需要考虑这部分的空间开销）。可以限制递归调用的最大深度来解决这个问题。
```java
int depth = 0;
int f(int n){
  ++depth;
  if(depth > 10000) throw exception;
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```


- 警惕重复计算
从图中，我们可以直观地看到，想要计算f(5)，需先计算f(4)和f(3)。计算f(4)还要计算f(3)。因此，f(3)被计算了很多次。我们可以通过一个散列表来保存已经求解过的f(k)。当递归调用f(k)，如果已经求解过，可以直接从散列表中取值返回。
<img src="12.jpg" style="max-width: 500px">
```java
public int f(int n){
  if (n == 1) return 1;
  if (n == 2) return 2;

  if (hasSolvedList.containKey(n)){
    return hasSolvedList.get(n);
  }

  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
```

- 无限递归
比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据，出现A-B-C-A这样的死循环。可以用限制递归深度解决，也可以自动检测A-B-C-A（用散列表记录已经查过的数据）。

<br/>
<br/>
### 6. 排序
原地排序：空间复杂度为O(1)的算法
稳定排序：相同的元素在排序后保持原有的顺序不变
有序度: 接近有序/完全无序。
*有序度*是数组中具有有序关系的元素对的个数。

<br/>
#### 6.1 冒泡排序
对一组数组4,5,6,3,2,1从小到大进行排序。
<img src="13.jpg" style="max-width: 500px">

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会比较相邻的两个元素，看要不要让它们互换位置。一次冒泡会让至少一个元素移动到它应该的位置，重复n次，就完成了n个数据的排序工作。
```java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n){
  if (n <= 1) return;
  for(int i = 0; i < n; ++i){
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for(int j = 0; j < n - i - 1; ++j){
      if (a[j] > a[j+1]){
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true; // 表示有数据交换
      }
    }
    if(!flag) break;  // 没有数据交换，提前退出
  }
}
```
冒泡排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)

<br/>
#### 6.2 插入排序
插入排序将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。然后取未排序区间中的元素，在已排序区间中找到合适的位置插入，并保证已排序区间数据一直有序。
<img src="14.jpg" style="max-width: 500px">
```java
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n){
  if (n <= 1) return;
  for(int i = 1; i < n; ++i){
    // value 要插入的元素
    int value a = [i];
    int j = i - 1;
    // 查找插入的位置
    for(; j >= 0; --j){
      if (a[j] > value){
        a[j+1] = a[j];  // 已排序区间中比value大的元素均往后移一格
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```
插入排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)

<br/>
#### 6.3 选择排序
选择排序每会从末排序区间中找到最小的元素，将其放到已排序区间的末尾。
<img src="15.jpg" style="max-width: 500px">
选择排序是原地排序算法，是一种不稳定的排序算法，最好情况事件复杂度和最坏情况时间复杂度都是O(n²)

<br/>
#### 6.4 归并排序
先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。
<img src="16.jpg" style="max-width: 500px">

#### 6.5 快速排序

<br/>
### 7. 堆 

### 8. 回溯
很多经典的数学问题可以用回溯算法解决，如数独、八皇后、0-1背包、图的着色、旅行商问题、全排列等。

我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，都会面对一个岔路口，我们先选一条路走，当发现这条路走不通的时候，就回退到上一个岔路口，另选一种走法继续走。

- 0-1背包问题：背包总的承载重量是 W kg，现在有 n 个物品，每个物品重量不等，并且不可分割。如何让背包中物品的总重量最大？

n个物品，总的装法就有2^n种。我们如何才能不重复穷举这2^n种装法？