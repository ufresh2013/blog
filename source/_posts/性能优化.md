---
title: 性能优化
date: 2019-09-30 13:10:09
category: Browser
---
从输入 URL 到页面加载完成，经历了下面几个步骤，针对这些步骤逐个优化：

优化点|问题|解决
---|:--:|---:
DNS解析| 减少DNS解析次数，把解析前置？|DNS缓存和DNS prefetch
TCP连接 | TCP三次握手，时间太久？ | 长连接，预连接，接入SPDY协议
HTTP请求| HTTP请求怎么优化？ | 减少请求次数和请求体积，CDN等网络层面的性能优化
浏览器渲染 | 拿到内容后，如何加快响应速度？ | 资源加载优化、服务端渲染、浏览器缓存机制、DOM树构建、<br/>网页排版和渲染、回流和重绘、DOM操作合理规避等问题。

总的来说，前端性能优化可以分为 *网络层面* 和 *渲染层面* 两个大点。


<br/>

### 1. 网络层面
- Webpack优化
- 浏览器缓存，离线缓存
- 对于不需要缓存的资源，使用Cache-control: no-store
- 对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用Cache-control: no-cache并配合ETag，表示该资源已被缓存，但是每次都会发送请求询问资源是否需要更新
- 对于代码文件，通常使用Cache-control: max-age=31536000强缓存，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

- HTTP压缩
在request header中加上`accept-encoding:gzip`
- 图片优化
图片在 HTTP 传输里占有非常高的比例，虽然它本身已经被压缩过了，不能被 gzip、br 处理，但仍然有优化的空间。比如说，去除图片里的拍摄时间、地点、机型等元数据，适当降低分辨率，缩小尺寸。图片的格式也很关键，尽量选择高压缩率的格式，有损格式应该用 JPEG，无损格式应该用 Webp 格式。

对于小文本或者小图片，还有一种叫做“资源合并”（Concatenation）的优化方式，就是把许多小资源合并成一个大资源，用一个请求全下载到客户端，然后客户端再用 JS、CSS 切分后使用，好处是节省了请求次数，但缺点是处理比较麻烦。

<br/>

### 2. 渲染层面
### 加载性能
1. 压缩：将写好的 CSS 进行打包压缩
2. 单一样式：当需要下边距和左边距的时候，很多时候选择 `margin: top 0 bottom 0`，但`margin-bottom: bottom; margin-left: left;` 执行的效率更高
3. 减少使用 `@import`，而建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

### 选择器性能
1. 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等
2. 如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）
3. 避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择
4. 尽量少的去对标签进行选择，而是用 class
5. 尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素
6. 了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则

### 渲染性能
1. 慎重使用高性能属性：浮动、定位
2. 尽量减少页面重排、重绘  [回流、重绘、合成](https://www.notion.so/8d865ce2e9474b74b499fc8398ca5a9d) 
3. 去除空规则：`{}`，空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 CSS 文档体积
4. 属性值为 0 时，不加单位
5. ~~属性值为浮动小数 0.**，可以省略小数点之前的0~~
6. 标准化各种浏览器前缀：带浏览器前缀的在前，标准属性在后
7. 不使用 `@import` 前缀，它会影响 CSS 的加载速度
8. 选择器优化嵌套，尽量避免层级过深
9. CSS 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用
10. 正确使用 `display` 的属性，由于 `display` 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能
11. 不滥用web字体。对于中文网站来说 WebFonts可能很陌生，国外却很流行。web fonts 通常体积庞大，而且一些浏览器在下载 web fonts 时会阻塞页面渲染损伤性能

### 可维护性、健壮性
1. 将具有相同属性的样式抽离出来，整合并通过 class 在页面中进行使用，提高 CSS 的可维护性
2. 样式与内容分离：将 CSS 代码定义到外部 CSS 中



雅虎36条

*内容部分* | | 
---|---:
减少HTTP请求数   | 合并文件，CSS Sprites，行内图片(base64编码)
减少DNS查找      | 减少主机名
避免重定向       | 在Apache中用Alias, mod_rewrite或者DirectorySlash指令来取消不必要的重定向。
让ajax可缓存     | 浏览器缓存
延迟加载组件      | 
预加载组件        |
减少DOM元素的数量  | 使用更好的语义化标记
跨域分离组件      | HTML部署到`www.example.org`，而把静态组件分离到`static.example.org`。<br/>最大化并行下载，但要确保不超过2-4个域。
尽量少用iframe    | iframe阻塞页面加载；非语义
杜绝404           | 外部js链接报404，这种下载将阻塞并行下载，浏览器还会试图解析404响应体，<br/>因为它是js代码，需要找出其中可用的部分
*CSS部分*    | 
避免使用CSS表达式  | IE5支持，IE8后不支持
使用`<link>`不用`@import` | IE中用@import与在底部使用`<link>`效果一样
避免使用滤镜               | IE专有的AlphaImageLoader滤镜用来修复IE7之前的半透明PNG问题。<br/>应用PNG8图片来替代。
把样式表放在顶部  | 
*JS部分*        | 
去除重复的JS脚本      |
尽量减少DOM访问   | 缓存已访问过的元素；<br/>先“离线”更新节点，再把它们添加到DOM树上；<br/>避免用JS修复布局问题
使用事件委托      | 避免太多事件处理器被添加到DOM树的不同元素上
把脚本放在底部     | 使用defer脚本提示浏览器它们可以继续渲染。
把css和js放到外面  | HTML文件中的行内js和css在每次请求html文档的时候都会重新下载。<br/>外部js和css文件会被缓存在浏览器。因为被浏览器缓存起来，我们就把HTML文档变小了。
压缩css和js   |
*图片*        |
优化图片        | 
优化CSS Sprite  |
不要使用HTML缩放图片 |
用小的可缓存的favicon.ico | 浏览器会自动请求它，所以最好不要给它一个404。设置一张1K内的favicon.ico，设置合适的有效期HTTP头
*cookie* |
给cookie减肥 | 清除不必宝的cookie， 给cookie设置合适的域，设置有效期
把静态资源放在不含cookie的域下 | `static.example.org`不需要cookie信息
*服务器* | 
Gzip组件 | `Accept-Encoding: gzip, deflate`当服务器看到这个请求头，就会用gzip压缩响应
避免图片src为空 | `<img src="">` 或 `var img = new Image(); img.src = ""`
配置ETags | 
使用get请求 | 
使用CDN  | 
添加Expires或者Cache-Control HTTP请求头 | 





### 参考资料
- [雅虎前端优化的35条军规](https://www.cnblogs.com/xianyulaodi/p/5755079.html)
- [【性能优化指南】和你一起全面了解前端性能优化](https://www.zhihu.com/search?type=content&q=%E9%9B%85%E8%99%8E%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
- [2019 前端性能优化年度总结](https://juejin.im/post/5c4418006fb9a049c043545e)